<?php if (!defined("BASEPATH")) exit("No direct script access allowed");
/**
 * BaseCommentManager
 * This class has been auto-generated by Itirra
 */
require_once APPPATH . 'logic/base/BaseManager.php';
abstract class BaseCommentManager extends BaseManager {

  /**
   * getBySortorderWithPager
   * @param array $baseWhere
   * @param int $page
   * @param int $perPage
   * @param string $what
   */
  public function getBySortorderWithPager($baseWhere = array(), $page = 1, $perPage = 10, $what = 'e.*') {
    // TODO: Make it work for ASC and DESC order types (WARNING: now it work only for DESC)
    $where = array_merge($baseWhere, array('level' => 0));
    $entities = $this->getAllWhereWithMyPager($where, $page, $perPage, 'id, sortorder');
    if (empty($entities->data)) {
      return $entities;
    }

    // 1) Get sortorder of first root and (last root + 1) for current page
    $firstItem = $entities->data[0];
    $lastItem = $entities->data[count($entities->data)-1];

    $sortorderWhere['sortorder<='] = $firstItem['sortorder'];

    $where = array_merge($baseWhere, array('level' => 0, 'sortorder<' => $lastItem['sortorder']));
    $nextRootItemSortorder = $this->getOneWhere($where, 'id, sortorder');
    if (!empty($nextRootItemSortorder)) {
      $sortorderWhere['sortorder>'] = $nextRootItemSortorder['sortorder'];
    }

    // 2) Get all entities between these sortorders
    $entities->data = $this->getAllWhere($sortorderWhere, $what);

    return $entities;
  }

  /**
   * PreInsert.
   * OVERRIDE THIS METHOD IN A SUBCLASS.
   * @param array $entity
   */
  protected function preInsert(&$entity) {
    $this->validateEntity($entity);

    $this->startTransaction();
    if (isset($entity['parent_id']) && !empty($entity['parent_id'])) {
      $lastCommentForEntityAndParent = $this->getLastCommentForEntity($entity);
      if (!empty($lastCommentForEntityAndParent)) {
        $entity['level'] = $lastCommentForEntityAndParent['level'];
        $lastChild = $this->getLastChild($lastCommentForEntityAndParent);
        $entity['sortorder'] = $lastChild['sortorder'];
      } else {
        $parent = $this->getOneWhere(array('id' => $entity['parent_id']), 'id, sortorder, parent_id, level');
        $entity['level'] = $parent['level'] + 1;
        $entity['sortorder'] = $parent['sortorder'];
      }
      $this->incrementSortorderForEntity($entity);
    } else {
      $maxSortOrder = $this->getMaxSortorderForEntity($entity);
      $entity['level'] = 0;
      $entity['sortorder'] = $maxSortOrder + 1;
    }

    $this->commitTransaction();
  }

  /**
   * validateEntity
   * @param BaseCommentManager $entity
   */
  protected function validateEntity($entity) {
    if (!isset($entity['entity_id']) || empty($entity['entity_id'])) {
      show_error('BaseCommentManager: Entity ID cannot be empty');
    }
  }

  /**
   * getLastCommentForEntity
   * @param BaseCommentManager $entity
   */
  protected function getLastCommentForEntity($entity) {
    $baseOrder = $this->orderBy;
    $reverseOrder = 'sortorder ASC';
    if ($this->isSortorderAsc()) {
      $reverseOrder = 'sortorder DESC';
    }
    $this->setOrderBy($reverseOrder);
    $result = $this->getOneWhere(array('entity_id' => $entity['entity_id'], 'parent_id' => $entity['parent_id']), 'id, sortorder, entity_id, parent_id, level');
    $this->setOrderBy($baseOrder);
    return $result;
  }

  /**
   * incrementSortorderForEntity
   * @param BaseCommentManager $entity
   */
  protected function incrementSortorderForEntity(&$entity) {
    if ($this->isSortorderAsc()) {
      $entity['sortorder'] = $entity['sortorder'] + 1;
    }
    $this->getDQLUpdateAllWhereQuery(array('entity_id' => $entity['entity_id'], 'sortorder>' => $entity['sortorder'] - 1))->set('sortorder', 'sortorder + 1')->execute();
  }

  /**
   * getMaxSortorderForEntity
   * @param BaseCommentManager $entity
   */
  protected function getMaxSortorderForEntity($entity) {
    return $this->getMax('sortorder', array('entity_id' => $entity['entity_id']));
  }

  /**
   * PreDelete.
   * OVERRIDE THIS METHOD IN A SUBCLASS.
   * @param array $keyValueArray
   */
  protected function preDelete($keyValueArray) {
    show_error('BaseCommentManager: Comments can not be deleted');
  }

  /**
   * PostInsert.
   * OVERRIDE THIS METHOD IN A SUBCLASS.
   * @param array $entity
   */
  protected function postInsert($entity) {
    $this->commentsRecount($entity);
  }

  /**
   * PostUpdate.
   * OVERRIDE THIS METHOD IN A SUBCLASS.
   * @param array $entity
   */
  protected function postUpdate($entity) {
    $this->commentsRecount($entity);
  }

  /**
   * commentsRecount
   * @param BaseCommentManager $entity
   */
  protected function commentsRecount($entity) {
    $commentCount = $this->getCountWhere(array('entity_id' => $entity['entity_id']));
    ManagerHolder::get(str_replace('Comment', '', $this->entityName))->updateAllWhere(array('id' => $entity['entity_id']), array('comment_count' => $commentCount));
  }

  /**
   * getLastChild
   * @param BaseCommentManager $entity
   */
  protected function getLastChild($entity) {
    $operator = '<';
    if ($this->isSortorderAsc()) {
      $operator = '>';
    }
    $comments = $this->getAllWhere(array('entity_id' => $entity['entity_id'], 'sortorder' . $operator => $entity['sortorder']), 'id, sortorder, entity_id, parent_id, level');
    $result = $entity;
    foreach ($comments as $c) {
      if ($c['level'] < $entity['level']) {
        break;
      }
      $result = $c;
    }
    return $result;
  }

  /**
   * isSortorderAsc
   */
  protected function isSortorderAsc() {
    return strpos($this->orderBy, 'sortorder ASC') !== FALSE;
  }

}