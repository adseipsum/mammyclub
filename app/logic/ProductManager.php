<?php if (!defined("BASEPATH")) exit("No direct script access allowed");
/**
 * ProductManager
 * This class has been auto-generated by Itirra
 */
require_once APPPATH . 'logic/BaseProjectManager.php';
class ProductManager extends BaseProjectManager {

  /** Filters (getFiltersData) */
  private $filtersMap = array();

  /** Order by */
  protected $orderBy = "name ASC";

  /** Fields. */
  public $fields = array("name" => array("type" => "input", "class" => "required", "attrs" => array("maxlength" => 255)),
                         "page_url" => array("type" => "input", "class" => "required readonly", "attrs" => array("startwith" => "/продукт/", "depends" => "product_name", "readonly" => "readonly", "maxlength" => 255)),
                         "priority" => array("type" => "input_integer"),
                         "price" => array("type" => "input_integer", "class" => "required"),
                         "cost_price" => array("type" => "input"),
//                         "count" => array("type" => "input"),
                         "product_code" => array("type" => "input"),
                         "bar_code" => array("type" => "input", "class" => "barCodeGen"),
                         "item_group_id" => array("type" => "input"),
                         "category" => array("type" => "select", "class" => "required", "relation" => array("entity_name" => "ProductCategory")),
                         "brand" => array("type" => "select", "relation" => array("entity_name" => "ProductBrand")),
                         "filter_values" => array("type" => "array", "input-row-type" => "custom", "input-row-path" => "includes/admin/filter_values_array_row"),
                         "description" => array("type" => "tinymce", "attrs" => array("maxlength" => 65536)),
                         "description_short" => array("type" => "tinymce", "attrs" => array("maxlength" => 65536)),
                         "description_short2" => array("type" => "tinymce", "attrs" => array("maxlength" => 65536)),
                         "video" => array("type" => "textarea"),
                         "image" => array("type" => "image"),
                         "images" => array("type" => "image_list_ajax"),
                         "published" => array("type" => "checkbox"),
                         "templates_ignore" => array("type" => "checkbox"),
//                         "on_order" => array("type" => "checkbox", "class" => "readonly", "attrs" => array("disabled" => "disabled")),
                         "not_in_stock" => array("type" => "checkbox", "class" => "readonly", "attrs" => array("disabled" => "disabled")),
//                         "our_stock" => array("type" => "checkbox"),
                         "google_product_category" => array("type" => "input", "attrs" => array("maxlength" => 255)),
                         "head_section_code" => array("type" => "textarea", "class" => "charCounter"),
                         "header.title" => array("type" => "input", "class" => "required charCounter", "attrs" => array("depends" => "product_name", "maxlength" => 500)),
                         "header.description" => array("type" => "textarea", "class" => "charCounter"),
                         "possible_parameters" => array("type" => "include", "path" => "includes/admin/possible_parameters_row"),
                         "parameter_groups" => array("type" => "include", "path" => "includes/admin/parameter_group_array_row"),
                         "parameter_link" => array("type" => "select", "relation" => array("entity_name" => "Parameter")),
                         "parameter_value_link" => array("type" => "include", "path" => "includes/admin/parameter_value_link"),
                         "parameter_product_links" => array("type" => "include", "path" => "includes/admin/parameter_product_links_array"));

  /** List params. */
  public $listParams = array("product_code", "name", array("category" => "name"), array("brand" => "name"), "price", "cost_price", "published", "rating", "comment_count", "priority");

	/**
	 * addStoreCount
	 * @param array $entity
	 * @param array $inventories
	 */
  public function addStoreCount(&$entity, $inventories = array()) {
  	$entityIsProduct = isset($entity['parameter_groups']);
    $entity['in_stock_status'] = 'not_in_stock';

    if ($entity['not_in_stock']) {
      return TRUE;
    }

	  $entity['zammler_inventory_qty'] = 0;
	  $entity['mc_inventory_qty'] = 0;
	  $entity['other_stores_inventory_qty'] = 0;

    $storeReserves = array();
	  if (!empty($entity['reserves'])) {
      foreach ($entity['reserves'] as $reserve) {
        if (isset($storeReserves[$reserve['store_id']])) {
          $storeReserves[$reserve['store_id']] += $reserve['qty'];
        } else {
          $storeReserves[$reserve['store_id']] = $reserve['qty'];
        }
      }
    }

    if (!empty($inventories)) {
		  foreach ($inventories as $inventory) {
		  	if ($entity['bar_code'] != $inventory['bar_code'] && !$entityIsProduct) {
		  		continue;
			  }

        if ($inventory['qty'] != 0) {
          if ($inventory['store_id'] == ZAMMLER_STORE_ID) {
            if (isset($entity['zammler_inventory_qty'])) {
              $entity['zammler_inventory_qty'] += $inventory['qty'];
            } else {
              $entity['zammler_inventory_qty'] = $inventory['qty'];
            }
          } elseif ($inventory['store_id'] == MC_STORE_ID) {
            if (isset($entity['mc_inventory_qty'])) {
              $entity['mc_inventory_qty'] += $inventory['qty'];
            } else {
              $entity['mc_inventory_qty'] = $inventory['qty'];
            }
          } else {
            $entity['other_stores_inventory_qty'] += $inventory['qty'];
          }
        }
		  }

      if (isset($storeReserves[ZAMMLER_STORE_ID])) {
        $entity['zammler_inventory_qty'] = $entity['zammler_inventory_qty'] - $storeReserves[ZAMMLER_STORE_ID];
      }
      if (isset($storeReserves[MC_STORE_ID])) {
        $entity['mc_inventory_qty'] = $entity['mc_inventory_qty'] - $storeReserves[MC_STORE_ID];
      }
    }

	  if ($entity['zammler_inventory_qty'] > 0 || $entity['mc_inventory_qty'] > 0) {
      $entity['in_stock_status'] = 'in_stock';
    } elseif ($entity['other_stores_inventory_qty'] > 0) {
      $entity['in_stock_status'] = 'in_other_stock';
    }

    return TRUE;
  }

  /**
   * Update on order flag
   * @param $productId
   */
  public function updateOnOrderFlag($productId) {
    // TODO: DELETE
    return TRUE;
//    // Check parameter groups
//    $isWithParameterGroup = ManagerHolder::get('ParameterGroup')->existsWhere(array('product_id' => $productId));
//    if (!$isWithParameterGroup) {
//      $productOnOrder = $this->existsWhere(array('id' => $productId, 'on_order' => TRUE));
//      if ($productOnOrder) {
//        $this->updateWhere(array('id' => $productId, 'count>' => 0), 'on_order', FALSE);
//      } else {
//        $this->updateWhere(array('id' => $productId, 'count<=' => 0), 'on_order', TRUE);
//      }
//    } else {
//      ManagerHolder::get('ParameterGroup')->updateAllWhere(array('product_id' => $productId, 'count<=' => 0), array('on_order' => TRUE));
//      ManagerHolder::get('ParameterGroup')->updateAllWhere(array('product_id' => $productId, 'count>' => 0), array('on_order' => FALSE));
//      $hasNotOnOrderParameter = ManagerHolder::get('ParameterGroup')->existsWhere(array('product_id' => $productId, 'on_order' => FALSE));
//      if ($hasNotOnOrderParameter) {
//        $this->updateById($productId, 'on_order', FALSE);
//      } else {
//        $this->updateById($productId, 'on_order', TRUE);
//      }
//    }
  }


  /**
   * getFeeedExportFieldsMap
   * @param enum $type [facebook || google]
   */
  public function getFeeedExportFieldsMap($type) {

    $fields = array();

    if($type == 'facebook') {

      $fields['ID'] = 'id';
      $fields['title'] = 'name';
      $fields['price'] = 'price'; // автоматически добавлять в конце через пробел UAH
      $fields['sale_price'] = ''; // формат валюты как в колонке price
      $fields['sale_price_effective_date'] = ''; // формат ISO‑8601 (YYYY‑MM‑DD, думаю можно делать без часов и минут
      $fields['item_group_id'] = 'item_group_id';
      $fields['product_type'] = 'category.name';

      $fields['google_product_category'] = 'google_product_category';
      $fields['brand'] = 'brand.name';
      $fields['description'] = 'description_short2'; // strip tags
      $fields['availability'] = '';

      $fields['condition'] = ''; // везде равно New

      $fields['image_link'] = 'image';
      $fields['link'] = 'page_url';

    } elseif($type == 'google') {

      $fields['ID'] = 'id';
      $fields['Item title'] = 'name';
      $fields['price'] = 'price';
      $fields['Item Category'] = '';
      $fields['Image URL'] = 'image';
      $fields['Final URL'] = 'page_url';

    }

    return $fields;
  }



  /**
   * processFeedExportRow
   * @param array $entities
   * @param array $fields
   * @param enum $type [facebook || google]
   * @return array
   */
  public function processFeedExportRow($entities, $fields, $type) {

    if($type == 'google') {

      $remarketingCategoriesMap = ManagerHolder::get('RemarketingCategory')->getAll('e.*, product_categories.*');
      if(empty($remarketingCategoriesMap)) {
        log_message('debug', '[Cron_Controller -> remarketing_feed_export -> processFeedExportRow] - $remarketingCategoriesMap empty. Exiting');
        return;
      }

      $RCM = array();
      foreach ($remarketingCategoriesMap as $m) {
        if(!empty($m['product_categories'])) {
          $rCat = array('id'   => $m['id'],
                        'name' => $m['name']);
          if(!empty($m['product_categories'])) {
            foreach ($m['product_categories'] as $c) {
              $rCat['category_name'] = $c['name'];
              $RCM[$c['id']] = $rCat;
            }
          }
        }
      }
    }

    $rows = array();
    foreach ($entities as $e) {

    	// Add sale if available to temp var
			$entitieAddSale = $e;
	    ManagerHolder::get('Sale')->addAvailableForAllSaleToProducts($entitieAddSale);

      $row = array();

      if($type == 'facebook') {

        foreach ($fields as $k => $v) {
          if(strpos($v, '.') !== FALSE) {
            $vArr = explode('.', $v);
            $row[$k] = $e[$vArr[0]][$vArr[1]];
          } elseif (empty($v)) {
            $row[$k] = '';
            if($k == 'availability') {
              $row[$k] = 'available for order';
//              if($e['on_order'] == FALSE) {
              if($e['not_in_stock'] == FALSE) {
                $row[$k] = 'in stock';
              } else if ($e['not_in_stock'] == TRUE) {
                $row[$k] = 'out of stock';
              }
            }
	          if (!empty($entitieAddSale['sale'])) {
		          if ($k == 'sale_price') {
			          $row[$k] = $entitieAddSale['price'] . ' UAH';
		          }
		          if ($k == 'sale_price_effective_date') {
			          $row[$k] = date(DATE_ISO8601, strtotime($entitieAddSale['sale']['starts_at'])) . '/' . date(DATE_ISO8601, strtotime($entitieAddSale['sale']['ends_at']));
		          }
	          }
            if($k == 'condition') {
              $row[$k] = 'New';
            }
          } else {
            $row[$k] = $e[$v];
            if($k == 'price') {
              $row[$k] .= ' UAH';
            }
            if($k == 'description') {
              $row[$k] = html_entity_decode(strip_tags($e[$v]), ENT_QUOTES);
            }
            if($k == 'image_link') {
              $row[$k] = site_image_url($e[$v]);
            }
            if($k == 'link') {
              $row[$k] = shop_url($e[$v]);
            }
            if($k == 'google_product_category' && empty($e[$v])) {
              $row[$k] = $e['category']['google_product_category'];
            }
          }
        }

        $rows[] = $row;

      } elseif($type == 'google') {

        if(!isset($RCM[$e['category_id']])) {
//           log_message('debug', '[Cron_Controller -> remarketing_feed_export -> processFeedExportRow] - $e category is not found in RCM');
          continue;
        }

        if(!isset($rows[$RCM[$e['category_id']]['id']])) {
          $rows[$RCM[$e['category_id']]['id']] = array('name' => $RCM[$e['category_id']]['name'],
                                                       'rows' => array());
        }

        foreach ($fields as $k => $v) {
          if($k == 'Item Category') {
            $row[$k] = $RCM[$e['category_id']]['category_name'];
            continue;
          }
          if($k == 'Image URL') {
            $row[$k] = site_image_url($e[$v]);
            continue;
          }
          if($k == 'Final URL') {
            $row[$k] = shop_url($e[$v]);
            continue;
          }
          $row[$k] = $e[$v];
          if($k == 'price') {
            $row[$k] .= ' UAH';
          }
        }

        $rows[$RCM[$e['category_id']]['id']]['rows'][] = $row;
      }

    }

    return $rows;
  }

  /**
   * getFilterData for filters
   * @param array $baseWhere
   * @param array $where
   * @param array $filters
   * @return array
   */
  public function getFilterData($baseWhere, $filteredWhere, $filters = array()) {

    $diffWhere = array();
    if($baseWhere != $filteredWhere) {
      foreach ($baseWhere as $k => $bw) {
        if($k == 'categories.id') {
          if($baseWhere[$k] != $filteredWhere[$k]) {
            $filteredWhere['categories'] = $filteredWhere[$k];
          }
        }
        unset($filteredWhere[$k]);
      }
      $diffWhere = $filteredWhere;
      $filterValuesInWhere = array();
      if(isset($diffWhere['filter_values.id'])) {
        $filterValuesInWhere = $diffWhere['filter_values.id'];
        $tempFilterValues = array();
        foreach ($diffWhere['filter_values.id'] as $fvgroup) {
          foreach ($fvgroup as $fv) {
            $tempFilterValues[] = $fv;
          }
        }
        $diffWhere['filter_values'] = $tempFilterValues;
        unset($diffWhere['filter_values.id']);
      }
    }

    // Define the result array
    $result = array('minPrice' => 0,
                    'maxPrice' => 0,
                    'filters' => array(),
                    'brands' => array());

    // Get product data from db
    $what = array('id', 'price', 'brand_id', 'filter_values.id');

    // Get filtered list of products
    $productsFiltered = array('brand_id' => array(),
                              'filter_values' => array(),
                              'price' => array());
    $productsFilteredKeys = array_keys($productsFiltered);

    // If entity type is category - adding tags logic
    if(!empty($filters)) {
      $tempFilterArr = array();
      foreach ($filters as $filter) {
        $tempFilterArr[$filter['id']] = get_array_vals_by_second_key($filter['filtervalues'], 'id');
      }
      $this->filtersMap = $tempFilterArr;
    }

//     echo 'filtersMap: ';
//     trace($this->filtersMap);
//     echo '$filterValuesInWhere: ';
//     trace($filterValuesInWhere);

    // Get products
    $products = ManagerHolder::get('Product')->getAllWhere($baseWhere, $what);

    $brandsFilterValues = get_array_vals_by_second_key($products, 'brand_id');
    $brandsFilterValues = array_unique($brandsFilterValues);
    foreach ($brandsFilterValues as $k => $brandsFilterValue) {
      $brandsFilterValues[$k] = 'b' . $brandsFilterValue;
    }
    $this->filtersMap['brand'] = $brandsFilterValues;

    foreach ($products as $p) {

      // Simplify array data
      if(!empty($p['filter_values'])) {
        $p['filter_values'] = get_array_vals_by_second_key($p['filter_values'], 'id');
      }

      if (!empty($p['brand_id'])) {
        $p['filter_values'][] = 'b' . $p['brand_id'];
      }

      // Processing products filtered
      foreach ($productsFilteredKeys as $pfKey) {

        // Step 1. If no filters have been forced
        if(empty($diffWhere)) {
          $this->processProductsFiltered($productsFiltered, $pfKey, $p);
          continue;
        }

        // With filters (unset current iteration key from where)
        $diffWhereLocal = $diffWhere;
        unset($diffWhereLocal[$pfKey]);
        if($pfKey == 'price') {
          unset($diffWhereLocal['price BETWEEN']);
        }

        if(empty($diffWhereLocal)) {
          // Case when where array is empty after key was unseted from where array. Just like Step 1.
          $this->processProductsFiltered($productsFiltered, $pfKey, $p, $filterValuesInWhere);
          continue;
        }

        // Step 2. Filtering products
        $filterResult = $this->filterProducts($diffWhereLocal, $p);
        if($filterResult == FALSE) {
          continue;
        }

        $this->processProductsFiltered($productsFiltered, $pfKey, $p, $filterValuesInWhere);
      }
    }

    // Brands (names & count)
    if(!empty($productsFiltered['brand_id'])) {
      $brandIds = array_keys($productsFiltered['brand_id']);
      ManagerHolder::get('ProductBrand')->setOrderBy('name ASC');
      $brandsData = ManagerHolder::get('ProductBrand')->getAllWhere(array('id' => $brandIds), 'id, name');
      foreach ($brandsData as $k => &$br) {
        $br['count'] = $productsFiltered['brand_id'][$br['id']];
        if($br['count'] == 0) {
          unset($brandsData[$k]);
          continue;
        }
      }
      $result['brands'] = $brandsData;
    }

    // Tags (names & count)
    if(!empty($productsFiltered['filter_values'])) {
      $filterValueIds = array();
      $brandsValueIds = array();
      $productsFilteredValues = array_keys($productsFiltered['filter_values']);
      foreach ($productsFilteredValues as $value) {
        if (is_numeric($value)) {
          $filterValueIds[] = $value;
        } else {
          $brandsValueIds[] = str_replace('b', '', $value);
        }
      }
      if (!empty($filterValueIds)) {
        $filterValues = ManagerHolder::get('FilterValue')->getAllWhere(array('id' => $filterValueIds), 'id, name, filter.*');
        $filters = array();
        foreach ($filterValues as $fv) {
          if(!isset($filters[$fv['filter']['id']])) {
            $filters[$fv['filter']['id']] = $fv['filter'];
            $filters[$fv['filter']['id']]['filter_values'][$fv['id']] = array('id' => $fv['id'], 'name' => $fv['name'], 'count' => $productsFiltered['filter_values'][$fv['id']]);
          } else {
            if(!isset($filters[$fv['filter']['id']]['filter_values'][$fv['id']])) {
              $filters[$fv['filter']['id']]['filter_values'][$fv['id']] = array('id' => $fv['id'], 'name' => $fv['name'], 'count' => $productsFiltered['filter_values'][$fv['id']]);
            }
          }
        }
      }

      if (!empty($brandsValueIds)) {
        $brandValues = ManagerHolder::get('ProductBrand')->getAllWhere(array('id' => $brandsValueIds), 'id, name');
        $filters['brand'] = array('id' => 'brand', 'name' => 'Бренд');
        foreach ($brandValues as $bv) {
          $filters['brand']['filter_values'][$bv['id']] = array('id' => 'b' . $bv['id'], 'name' => $bv['name'], 'count' => $productsFiltered['filter_values']['b' . $bv['id']]);
        }
      }

      $result['filters'] = array_values($filters);
    }

    if(!empty($productsFiltered['price'])) {
      $result['minPrice'] = $productsFiltered['price']['min'];
      $result['maxPrice'] = $productsFiltered['price']['max'];
    }

    return $result;
  }

  /**
   * processProductsFiltered
   * @param array $productsFiltered
   * @param string $pfKey
   * @param array $p
   */
  private function processProductsFiltered(&$productsFiltered, $pfKey, &$p, $filterValuesInWhere = array()) {

    if($pfKey == 'price') {
      if(!isset($productsFiltered[$pfKey]['min']) && !isset($productsFiltered[$pfKey]['max'])) {
        $productsFiltered[$pfKey]['min'] = $p[$pfKey];
        $productsFiltered[$pfKey]['max'] = $p[$pfKey];
        return;
      }
      if ($p[$pfKey] < $productsFiltered[$pfKey]['min']) {
        $productsFiltered[$pfKey]['min'] = $p[$pfKey];
      }
      if ($p[$pfKey] > $productsFiltered[$pfKey]['max']) {
        $productsFiltered[$pfKey]['max'] = $p[$pfKey];
      }
    } else {

      if($pfKey == 'filter_values') {

//         trace('========= PRODUCT (' . $p['id'] . ')');
//         trace($p);
//         trace('before');
//         trace($productsFiltered['filter_values']);

        $productFilterMap = array();
        foreach ($this->filtersMap as $fId => $filterValues) {
          $productFilterMap[$fId] = array();
          foreach ($filterValues as $fv) {
            if(in_array($fv, $p['filter_values'])) {
              $productFilterMap[$fId][] = $fv;
            }
          }
          if(empty($productFilterMap[$fId])) {
            unset($productFilterMap[$fId]);
          }
        }

        foreach ($this->filtersMap as $fId => $filterValues) {

          $currentlyApplied = FALSE;
          if (isset($filterValuesInWhere[$fId])) {
            $currentlyApplied = TRUE;
          }

          $otherFilterValues = array();
          foreach ($filterValuesInWhere as $fId2 => $filterValues2) {
            if ($fId != $fId2) {
              $otherFilterValues = array_merge($otherFilterValues, $filterValues2);
            }
          }

//           trace('$currentlyApplied');
//           trace($currentlyApplied);

//           trace('$otherFilterValues');
//           trace($otherFilterValues);

          if ($currentlyApplied) {

            foreach ($filterValues as $fvId) {

              if (in_array($fvId, $filterValuesInWhere[$fId])) {
                // Logic of counting unpress
                $productsFiltered['filter_values'][$fvId] = 0;
                continue;
              }

              // posle dobavleniya filtra po $fvId
              $productWillBeShownAfterNewFilter = FALSE;

              $productHasCurrentFilterValuesInCurrentGroup = TRUE;
              // product has current filters values
              foreach ($otherFilterValues as $filterValueInWhere) {
                if (!in_array($filterValueInWhere, $p['filter_values'])) {
                  $productHasCurrentFilterValuesInCurrentGroup = FALSE;
                }
              }

              // Check if applied filter value of current group is related to curren fv
              $hasMatches = FALSE;
              foreach ($filterValuesInWhere[$fId] as $FVWId) {
                if(isset($productFilterMap[$fId]) && in_array($FVWId, $productFilterMap[$fId])) {
                  $hasMatches = TRUE;
                }
              }
              if($hasMatches == TRUE) {
                $productHasCurrentFilterValuesInCurrentGroup = FALSE;
              }
              // =======================================================================

              if ($productHasCurrentFilterValuesInCurrentGroup && in_array($fvId, $p['filter_values'])) {
                $productWillBeShownAfterNewFilter = TRUE;
              }

              if ($productWillBeShownAfterNewFilter) {
                if (!isset($productsFiltered['filter_values'][$fvId])) {
                  $productsFiltered['filter_values'][$fvId] = 1;
                } else {
                  $productsFiltered['filter_values'][$fvId]++;
                }
              }
            }

//             trace('after');
//             trace($productsFiltered['filter_values']);

          } else {

            foreach ($filterValues as $fvId) {

              // posle dobavleniya filtra po $fvId
              $productWillBeShownAfterNewFilter = FALSE;

              $productHasCurrentFilterValues = FALSE;
              // product has current filters values
              if (empty($filterValuesInWhere)) {
                $productHasCurrentFilterValues = TRUE;
              } else {

                foreach ($otherFilterValues as $filterValueInWhere) {
                  if (in_array($filterValueInWhere, $p['filter_values'])) {
                    $productHasCurrentFilterValues = TRUE;
                  }
                }

                // Check if this combination is possible for a product
                foreach ($filterValuesInWhere as $fGrId => $filterValuesWhere) {
                  if(!isset($productFilterMap[$fGrId])) {
                    $productHasCurrentFilterValues = FALSE;
                    break;
                  }
                  $hasMatches = FALSE;
                  foreach ($filterValuesWhere as $FVId) {
                    if(in_array($FVId, $productFilterMap[$fGrId])) {
                      $hasMatches = TRUE;
                    }
                  }
                  if($hasMatches == FALSE) {
                    $productHasCurrentFilterValues = FALSE;
                    break;
                  }
                }
                // =======================================================================

              }

              if ($productHasCurrentFilterValues && in_array($fvId, $p['filter_values'])) {
                $productWillBeShownAfterNewFilter = TRUE;
              }

              if ($productWillBeShownAfterNewFilter) {
                if (!isset($productsFiltered['filter_values'][$fvId])) {
                  $productsFiltered['filter_values'][$fvId] = 1;
                } else {
                  $productsFiltered['filter_values'][$fvId]++;
                }
              }

            }

          }

        }

      } elseif($pfKey == 'categories') {
        foreach ($p[$pfKey] as $cId) {
          if (!isset($productsFiltered[$pfKey][$cId])) {
            $productsFiltered[$pfKey][$cId] = 1;
          } else {
            $productsFiltered[$pfKey][$cId]++;
          }
        }
      } else {
        if (!isset($productsFiltered[$pfKey][$p[$pfKey]])) {
          $productsFiltered[$pfKey][$p[$pfKey]] = 1;
        } else {
          $productsFiltered[$pfKey][$p[$pfKey]]++;
        }
      }

    }
  }


  /**
   * filterProducts
   * @param array $diffWhereLocal
   * @param array $p
   */
  private function filterProducts($diffWhereLocal, $p) {

    foreach ($diffWhereLocal as $k => $v) {

      if(is_array($v)) {
        if(in_array($k, array('filter_values', 'categories'))) {

          if(empty($p[$k])) {
            return FALSE;
          }

          $matches = FALSE;
          foreach ($v as $vv) {
            if(in_array($vv, $p[$k])) {
              $matches = TRUE;
              break;
            }
          }
          if($matches == FALSE) {
            return FALSE;
          }

        } else {
          if(!in_array($p[$k], $v)) {
            return FALSE;
          }
        }
      } else {
        if(strpos($k, 'BETWEEN') !== FALSE) {
          $pKey = str_replace(' BETWEEN', '', $k);
          $valueArr = explode(' AND ', $v);
          if($p[$pKey] < $valueArr[0] || $p[$pKey] > $valueArr[1]) {
            return FALSE;
          }
        } else {
          if($p[$k] != $v) {
            return FALSE;
          }
        }
      }

    }
    return TRUE;
  }

//   /**
//    * ProcessKeyValueArray.
//    * Method to turn KEY=VALUE array into WHERE parts of a Doctrtine ActiveRecord
//    * @param Doctrine_Query $query
//    * @param array $keyValueArray
//    * @param string $pref
//    * @return Doctrine_Query
//    */
//   protected function processKeyValueArray($query, $keyValueArray, $pref = 'e') {
//     if (!is_array($keyValueArray) || empty($keyValueArray)) return $query;
//     $defPref = $pref . '.';
//     foreach ($keyValueArray as $key => $value) {
//       $pref = $defPref;
//       if (strstr($key, ".") !== FALSE) {
//         $pref = '';
//       }
//       if (strstr($key, "BETWEEN") !== FALSE) {
//         $oldKey = $key;
//         $key = str_replace("BETWEEN", "", $key);
//         $key = trim($key);
//         $this->replaceSelectField($query, $oldKey, $key);
//         $value = explode("AND", $value);
//         $value = array_merge($value, $value);
//         if($key == 'price') {
//           $query->andWhere($pref . $key . ' BETWEEN ? AND ? AND ' . $pref . 'sale_price = 0 OR ' . $pref . 'sale_price BETWEEN ? AND ?', $value);
//           unset($keyValueArray[$key]);
//           continue;
//         }
//       }
//       if (strpos($key, 'filter_values') !== FALSE) {
//         $i = 0;
//         foreach ($keyValueArray[$key] as $fiterValuesGroup) {
//           if($i == 0) {
//             $query->andWhereIn($pref . $key, $fiterValuesGroup);
//           } else {
//             $query->orWhereIn($pref . $key, $fiterValuesGroup);
//           }
//           $i++;
//         }
//         unset($keyValueArray[$key]);
//         continue;
//       }
//     }
//     $query = parent::processKeyValueArray($query, $keyValueArray, $pref = 'e');
//     return $query;
//   }

  /**
   * Returns array of relative site urls and other info of all entities to be used in stiemap.xml
   * @return array of arrays for entities: loc, lastmod, changefreq, priority. Only loc is mandatory.
   * @example 'loc'=>'item/1', 'lastmod'=>'1990-01-21', 'changefreq'=>'daily', 'priority'=>0.5
   * @see http://www.sitemaps.org/ru/protocol.html#xmlTagDefinitions
   */
  public function getAllForSitemap() {
    $products = $this->getAllWhere(array('published' => TRUE), 'e.*');

    $urls = array();
    if (!empty($products)) {
      foreach ($products as $p) {
        $urls[] = array('loc' => $p['page_url']);
      }
    }

    return $urls;
  }

  /**
   * processSortorder
   * instock -> on_order=0
   * out of stock -> not_in_stock=1
   * available for order -> on_order=1&not_in_stock=0
   */
  public function processSortorder() {

    $products = $this->getAllWhere(array('not_in_stock' => FALSE), 'id, priority, not_in_stock');
    if(empty($products)) {
      return;
    }

    $groupedByPriority = array('instock'  => array(),
                               'available' => array());
    foreach ($products as $k => $p) {
//      if($p['on_order'] == FALSE) {
      if($p['not_in_stock'] == FALSE) {
        if(empty($p['priority'])) {
          $groupedByPriority['instock'][0][] = $p['id'];
        } else {
          $groupedByPriority['instock'][$p['priority']][] = $p['id'];
        }
        unset($products[$k]);
      } else {
        if(empty($p['priority'])) {
          $groupedByPriority['available'][0][] = $p['id'];
        } else {
          $groupedByPriority['available'][$p['priority']][] = $p['id'];
        }
      }
    }

    $offset = 1;
    foreach ($groupedByPriority as $g) {
      ksort($g);
      foreach ($g as $priority => $ids) {
        // SET @Lower = 1 ---- The lowest random number
        // SET @Upper = 999 ---- The highest random number
        // SELECT @Random = ROUND(((@Upper - @Lower -1) * RAND() + @Lower), 0)
        $updateQ = 'UPDATE product SET sortorder = ROUND(((' . (count($ids)+$offset) . ' - ' . $offset . ' - 1) * RAND() + ' . $offset . '),0) WHERE id IN (' . implode(',', $ids) . ')';
//         log_message('error', '[process_product_random] - Processing query: ' . $updateQ);
        ManagerHolder::get('Product')->executeNativeSQL($updateQ);
        $offset += count($ids);
      }

    }

  }


  /**
   * Filter Values
   * @param string $filterName
   * @return array
   */
  public function getFilterValues($filterName) {

    if($filterName == 'stock_status') {
      return array("in_stock"     => lang("enum.product.stock_status.in_stock"),
                   "not_in_stock" => lang("enum.product.stock_status.not_in_stock"));
    }

    return parent::getFilterValues($filterName);
  }

  /**
   * PostInsert.
   * OVERRIDE THIS METHOD IN A SUBCLASS.
   * @param array $entity
   */
  protected function postInsert($entity) {
    if (isset($entity['templates_ignore']) && $entity['templates_ignore'] == FALSE) {
      $this->processTemplates($entity['id'], 'e.*');
    }

    if (isset($entity['id'])) {
      ManagerHolder::get('StoreInventory')->createDefault($entity['id'], str_replace('Manager', '', self::class));
    }
  }

  /**
   * PostUpdate.
   * OVERRIDE THIS METHOD IN A SUBCLASS.
   * @param array $entity
   */
  protected function postUpdate($entity) {
    if (isset($entity['templates_ignore']) && $entity['templates_ignore'] == FALSE) {
      $this->processTemplates($entity['id'], 'e.*');
    }

    if (isset($entity['id'])) {
      if (!is_array($entity['id'])) {
        ManagerHolder::get('StoreInventory')->createDefault($entity['id'], str_replace('Manager', '', self::class));
      }
    }
  }

  /**
   * PreUpdateWhere.
   * OVERRIDE THIS METHOD IN A SUBCLASS.
   * @param entity $entity
   */
  protected function preUpdate(&$entity) {
    $entityFromDb = ManagerHolder::get($this->entityName)->getById($entity['id'], 'page_url, count');
    if ($entityFromDb['page_url'] != $entity['page_url']) {
      $redirectData = array('old_url' => $entityFromDb['page_url'],
                            'new_url' => $entity['page_url']);
      // Check if we already have a redirect from current old url or eternal cycle
      $checkWhereArray = array(array('old_url' => $redirectData['old_url']),
                               array('old_url' => $redirectData['new_url'],
                                     'new_url' => $redirectData['old_url']));
      foreach ($checkWhereArray as $where) {
        $redirectUrl = ManagerHolder::get('RedirectUrl')->getOneWhere($where, 'e.*');
        if (!empty($redirectUrl)) {
          ManagerHolder::get('RedirectUrl')->deleteById($redirectUrl['id']);
        }
      }
      ManagerHolder::get('RedirectUrl')->insert($redirectData);
    }
    if ($entityFromDb['count'] != $entity['count']) {
      $entity['last_revision_date'] = date(DOCTRINE_DATE_FORMAT);
    }
  }

  /**
   * OnUpdateException.
   * OVERRIDE THIS METHOD IN A SUBCLASS.
   * @param array $entity
   * @param object $exception
   */
  protected function onUpdateException($entity, Exception $exception) {
    if ($exception->getCode() == DOCTRINE_DUPLICATE_ENTRY_EXCEPTION_CODE) {
      $entityFromDb = $this->getById($entity['id'], 'e.*');
      // Check if we already have a redirect from current old url or eternal cycle
      $checkWhereArray = array(array('old_url' => $entityFromDb['page_url']),
                               array('old_url' => $entity['page_url'],
                                     'new_url' => $entityFromDb['page_url']));
      foreach ($checkWhereArray as $where) {
        $redirectUrl = ManagerHolder::get('RedirectUrl')->getOneWhere($where, 'e.*');
        if (!empty($redirectUrl)) {
          ManagerHolder::get('RedirectUrl')->deleteById($redirectUrl['id']);
        }
      }
    }
  }

  /**
   * PreProcessWhereQuery.
   * OVERRIDE THIS METHOD IN A SUBCLASS TO ADD joins and other stuff.
   * @param Doctrine_Query $query
   * @return Doctrine_Query
   */
  protected function preProcessWhereQuery($query, $pref, $what = "*") {

    $relations = $this->getRelations();
    foreach ($relations as $alias => $class) {
      // No joins with Mongo!
      if (class_exists($class)) {
        $refl = new ReflectionClass($class);
        $constants = $refl->getConstants();
        if (isset($constants['TYPE']) && strtolower($constants['TYPE']) == 'mongodb') {
          continue;
        }
      }
      if (((strpos($what, $alias . '.') !== FALSE) || $what == '*') && $alias != 'translations') {
        if ($what == '*') {
          $query->addSelect($alias . ".*")->leftJoin($pref . "." . $alias . " " . $alias);
        } else {
          $query->leftJoin($pref . "." . $alias . " " . $alias);
        }
        if (isset($this->fields[$alias]) && $this->fields[$alias]['type'] == 'image_list' ||
        isset($this->fields[$alias]) && $this->fields[$alias]['type'] == 'image_list_alt' ||
        isset($this->fields[$alias]) && $this->fields[$alias]['type'] == 'image_list_ajax') {
          $query->addOrderBy($alias . ".priority DESC");
          $query->addSelect($alias . "_img.*")->leftJoin($alias . ".image " . $alias . "_img");
        }
      }
    }

    if (strpos($what, 'category.') !== FALSE || $what == '*') {
      $query->addSelect('filters.*')->leftJoin('category.filters filters');
    }

    if (strpos($what, 'possible_parameters.') !== FALSE || $what == '*') {
      $query->addSelect('parameter_main.*')->leftJoin('possible_parameters.parameter_main parameter_main');
      $query->addSelect('parameter_secondary.*')->leftJoin('possible_parameters.parameter_secondary parameter_secondary');
      $query->addSelect('possible_parameter_values.*')->leftJoin('possible_parameters.possible_parameter_values possible_parameter_values');
    }

    if (strpos($what, 'parameter_groups.') !== FALSE || $what == '*') {
      $query->addSelect('parameter_groups_values_out.*')->leftJoin('parameter_groups.secondary_parameter_values_out parameter_groups_values_out');
      $query->addSelect('parameter_groups_main.*')->leftJoin('parameter_groups.main_parameter_value parameter_groups_main');
      $query->addSelect('parameter_groups_image.*')->leftJoin('parameter_groups.image parameter_groups_image');
    }

    return $query;
  }

}