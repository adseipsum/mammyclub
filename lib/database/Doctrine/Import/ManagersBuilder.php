<?php
/*
 *  $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* This software consists of voluntary contributions made by many individuals
* and is licensed under the LGPL. For more information, see
* <http://www.doctrine-project.org>.
*/

/**
 * Doctrine_Import_ManagersBuilder
*
*/
class Doctrine_Import_ManagersBuilder extends Doctrine_Import_Builder
{

  protected $_baseManager = 'BaseManager';


  /**
   * overridden
   * @see lib/database/Doctrine/Import/Doctrine_Import_Builder::loadTemplate()
   */
  public function loadTemplate()
  {
    self::$_tpl = '/**'
    . '%s' . PHP_EOL
    . ' */' . PHP_EOL
    . '%s'
    . '%sclass %s extends %s {' . PHP_EOL
    . '%s' . PHP_EOL
    . '%s' . PHP_EOL
    . '}';
  }


  /**
   * overridden
   * @see lib/database/Doctrine/Import/Doctrine_Import_Builder::buildPhpDocs()
   */
  public function buildPhpDocs(array $definition)
  {
    $ret = array();

    $ret[] = $definition['className'];
    $ret[] = 'This class has been auto-generated by Itirra';
    $ret = ' * ' . implode(PHP_EOL . ' * ', $ret);
    $ret = ' ' . trim($ret);

    return $ret;
  }


  /**
   * overridden
   * @see lib/database/Doctrine/Import/Doctrine_Import_Builder::buildDefinition()
   */
  public function buildDefinition(array $definition, array $translation = array())
  {
    if ( ! isset($definition['className'])) {
      throw new Doctrine_Import_Builder_Exception('Missing class name.');
    }
    $abstract = isset($definition['abstract']) && $definition['abstract'] === true ? 'abstract ':null;
    $className = $definition['className'];

    if (isset($definition['actAs']) && !empty($definition['actAs']) && is_array($definition['actAs']) && in_array('NestedSet', array_keys($definition['actAs']))) {
      if (is_array($definition['actAs']['NestedSet']) && $definition['actAs']['NestedSet']['hasManyRoots'] == 1) {
        $extends = 'BaseTreeManager';
      } else {
        $extends = 'BaseSimpleTreeManager';
      }
    } elseif(isset($definition['type']) && $definition['type'] == 'mongodb') {
      $extends = 'BaseMongoDBManager';
    } else {
      $extends = isset($definition['inheritance']['extends']) ? $definition['inheritance']['extends'] . 'Manager': $this->_baseManager;
    }

    if ( ! (isset($definition['no_definition']) && $definition['no_definition'] === true)) {
      $tableDefinitionCode = $this->buildTableDefinition($definition, $translation);
      $setUpCode = '';//$this->buildSetUp($definition);
    } else {
      $tableDefinitionCode = null;
      $setUpCode = null;
    }

    $docs = PHP_EOL . $this->buildPhpDocs($definition);

    $require = "require_once APPPATH . 'logic/base/" . $extends . ".php';" . PHP_EOL;

    $content = sprintf(self::$_tpl, $docs, $require, $abstract,
    $className,
    $extends,
    $tableDefinitionCode,
    $setUpCode);

    return $content;
  }


  /**
   * overridden
   * @see lib/database/Doctrine/Import/Doctrine_Import_Builder::buildRecord()
   */
  public function buildTableDefinition(array $definition, array $translation = array())
  {
    $properties = $this->buildPropertiesForManager($definition, $translation);
    $code = $this->buildFieldsForManager($definition);
    $code = trim($code);
    if ($code) {
      $code1 = PHP_EOL . '  /** Fields. */';
      $code = $code1 . PHP_EOL . '  public $fields = array(' . $code;
    }
    if (!empty($properties) && $properties != PHP_EOL) {
      $code = $properties . PHP_EOL . $code;
    }

//    $filters = $this->buildFilters($definition);
//    if (!empty($filters)) {
//      $code = $code . $filters;
//    }

    return $code;
  }


  /**
   * buildPropertiesForManager
   * @param array $definition
   */
  public function buildPropertiesForManager(array $definition, array $translation = array()) {
    $build = "";
    $build .= $this->buildProperty('namefield', $definition);
    if (!empty($translation)) {
      $build .= $this->buildProperty('i18nFields', $translation);
    }
    $build .= $this->buildProperty('orderby', $definition);
    return $build;
  }


  /**
   * buildProperty
   * @param $name
   * @param $columns
   * @return string
   */
  private function buildProperty($name, $definition) {
    $columns = $definition['columns'];
    $result = '';

    // name field logic
    if($name == 'namefield') {
      if(!isset($columns['name'])) {
        if (isset($columns['id'])) {
          $result = PHP_EOL . '  /** Name field. */' . PHP_EOL;
          $result .= '  protected $nameField = "id";' . PHP_EOL;
        } else {
          // NO "ID" OR "NAME" -> ONLY MANY-TO-MANY TABLE! Create PK array
          $pks = array();
          foreach ($columns as $cName => $cVal) {
            if (isset($cVal['primary']) && $cVal['primary'] == TRUE) {
              $pks[] = $cName;
            }
          }
          if (!empty($pks)) {
//            if (count($pks) > 1) {
            $result = PHP_EOL . '  /** Primary Key Field. */' . PHP_EOL;
            $result .= '  protected $pk = array("' . implode('", "', $pks) . '");' . PHP_EOL;
//            } else {
//              $result = PHP_EOL . '  /** Name field. */' . PHP_EOL;
//              $result .= '  protected $nameField = array("' . implode('", "', $pks) . '");' . PHP_EOL;
//            }
          }
        }
      }
    }

    //order by logic
    if($name == 'orderby') {
      $result = PHP_EOL . '  /** Order by */' . PHP_EOL;

      $isTimeStampable = is_array($definition['actAs']) && array_key_exists('Timestampable', $definition['actAs']);

      if(isset($columns['priority'])) {

        // there is a priority field
        $orderBy = "priority DESC";

      } elseif($isTimeStampable) {

        $field = "created";
        // created is disabled ?
        if(isset($definition['actAs']['Timestampable']['created']['disabled'])) {
          $field = 'updated';
        }
        // default field name or the defined one?
        if(isset($definition['actAs']['Timestampable'][$field]['name'])) {
          $field = $definition['actAs']['Timestampable'][$field]['name'];
        } else {
          $field .= '_at';
        }
        $orderBy = "$field DESC";
      } else {
      }

      if (isset($orderBy) && !empty($orderBy)) {
        $result .= '  protected $orderBy = "' . $orderBy . '";';
      } else {
        $result = "";
      }
    }

    // i18nFields field logic
    if($name == 'i18nFields') {
      $cKeys = array_keys($columns);
      $result = PHP_EOL . '  /** i18nFields. */' . PHP_EOL;
      $result .= '  public $i18nFields = array("' . implode('", "', $cKeys) . '");' . PHP_EOL;
    }

    return $result;
  }


  /**
   * buildColumns
   *
   * @param string $array
   * @return void
   */
  public function buildFieldsForManager(array $definition)
  {
    if (isset($definition['inheritance']['type']) && ($definition['inheritance']['type'] == 'simple' || $definition['inheritance']['type'] == 'column_aggregation')) {
      return "";
    }

    $columns = $definition['columns'];

    // Add TimeStampable column
    $isTimeStampable = is_array($definition['actAs']) && array_key_exists('Timestampable', $definition['actAs']);
    if($isTimeStampable) {
      $field = "created";
      // created is disabled ?
      if(isset($definition['actAs']['Timestampable']['created']['disabled'])) {
        $field = 'updated';
      }
      // default field name or the defined one?
      if(isset($definition['actAs']['Timestampable'][$field]['name'])) {
        $field = $definition['actAs']['Timestampable'][$field]['name'];
      } else {
        $field .= '_at';
      }
      $columns[$field] = array('type' => 'datetime');
    }



    $listColumnsArr = array();

    $relations = array();
    if (isset($definition['relations'])) {
      foreach ($definition['relations'] as $relName => $rel) {
        if ($rel['type'] == 0) {
          $relations[$rel['local']] = $rel;
        } elseif (isset($rel['refClass'])) {
          $relations[$relName] = $rel;
          $columns[$relName] = array();
        }
      }
    }

    $arr = array();
    $i = 0;
    $build = null;
    $primaryIdFound = FALSE;
    foreach ($columns as $name => $column) {
      if (empty($column)) {
          continue;
      }
      $columnName = isset($column['name']) ? $column['name'] : $name;

      // Skip primary column
      if (isset($column['primary']) && $column['primary'] == TRUE && $columnName == 'id') {
        $primaryIdFound = TRUE;
        continue;
      }

      $relationStr = '';
      $classes = array();

      // Process NOTNULL
      if (isset($column['notnull']) && $column['notnull'] == TRUE && !isset($column['default'])) {
        $classes[] = 'required';
      }

      $attrs = '';
      $type = $column['type'];


      // Check whether it is a local relation
      if (isset($relations[$columnName])) {
        $relation = $relations[$columnName];
        if ($relation['class'] != 'Header') {
          if ($relation['class'] == 'Image') {
            $type = 'image';
            $columnName = $relation['alias'];
          } else if ($relation['class'] == 'Resource') {
            $type = 'file';
            $columnName = $relation['alias'];
          } else {

            if ($relation['type'] == 0) {
              $type = 'select';
              $columnName = $relation['alias'];
              $relationStr = '"relation" => array("entity_name" => "' . $relation['class'] . '")';
              $listColumnsArr[] =  $columnName . ".name";
            }
            if ($relation['type'] == 1) {
              $type = 'multipleselect';
              $columnName = $relation['alias'];
              $relationStr = '"relation" => array("entity_name" => "' . $relation['class'] . '", "search" => TRUE)';
              $listColumnsArr[] = array($relation['alias'] => "name");
            }
          }
        }
      } else {
        // Process Strings
        if ($column['type'] == 'string') {

          // Process page_url
          if ($columnName == 'page_url') {
            $depends = strtolower(str_replace('Manager', '', $definition['className'])) . '_name';
            $type = 'input';
            $attrs = '"attrs" => array("startwith" => "' . $column['default'] . '", "depends" => "' . $depends . '", "readonly" => "readonly", "maxlength" => ' . $column['length'] . ')';
            $classes[] = 'required';
            $classes[] = 'readonly';
          } else {
            if ($column['length'] <= 255) {
              $type = 'input';
              if ($columnName == 'name') {
                $listColumnsArr[] = $columnName;
              }
            } else {
              $type = 'textarea';
              $classes[] = 'charCounter';
            }
            $attrs = '"attrs" => array("maxlength" => ' . $column['length'] . ')';
          }
        }

        // Process Clobs
        if ($column['type'] == 'clob') {
          $type = 'tinymce';
          if(empty($column['length'])) {
            $column['length'] = 65536;
          }
          $attrs = '"attrs" => array("maxlength" => ' . $column['length'] . ')';
        }

        // Process Boolean
        if ($column['type'] == 'boolean') {
          $type = 'checkbox';
          $classes = array();
          $listColumnsArr[] = $columnName;
        }

        // Process Date
        if ($column['type'] == 'date') {
          $type = 'date';
          $listColumnsArr[] = $columnName;
        }

        // Process Enum
        if ($column['type'] == 'enum') {
          $type = 'enum';
          $listColumnsArr[] = $columnName;
        }

        // Process integer
        if ($column['type'] == 'integer') {
          $type = 'input_integer';
          $listColumnsArr[] = $columnName;
        }

        // Process double
        if ($column['type'] == 'double') {
          $type = 'input_double';
          $listColumnsArr[] = $columnName;
        }

        // Process decimal
        if ($column['type'] == 'decimal') {
          $type = 'input_double';
          $listColumnsArr[] = $columnName;
        }

        // Process timestamp
        if ($column['type'] == 'timestamp') {
          $type = 'datetime';
          $listColumnsArr[] = $columnName;
        }

        // Process datetime
        if ($column['type'] == 'datetime') {
          $type = 'datetime';
          $listColumnsArr[] = $columnName;
          if ($columnName == 'created_at') {
            $attrs = '"attrs" => array("disabled" => "disabled")';
            $classes[] = 'readonly';
          }
        }

      }


      // Classes
      $class = '';
      if (count($classes) > 0) {
        $class = '"class" => "';
        foreach ($classes as $cls) {
          $class .= $cls . " ";
        }
        $class = trim($class);
        $class .= '"';
      }

      if (!empty($attrs) && !empty($class)) {
        $class .= ', ';
      }

      $type = '"type" => "' . $type . '"';
      if (!empty($attrs) || !empty($class)) {
        $type .= ', ';
      }


      $build = '"' . $columnName . '" => array(' . $type . $class . $attrs . ($relationStr ? ', ' . $relationStr : '') . ')';

      if ($i > 0) {
        $build = '                         ' . $build;
      }

      $minus = 1;
      if ($primaryIdFound) {
        $minus = 2;
      }
      if ($i < count($columns) - $minus) {
        $build .= ',';
      }
      $i++;

      // special place for header_id
      if($columnName == 'header_id') {
        $dependsName = ', "depends" => "'. strtolower(str_replace('Manager', '', $definition['className'])) . '_name"';
        $arr[] = '                         "header.title" => array("type" => "input", "class" => "required", "attrs" => array("maxlength" => 255' . $dependsName . ')),';
        $dependsDescr = "";
        if (isset($columns['description'])) {
          $dependsDescr = ', "depends" => "'. strtolower(str_replace('Manager', '', $definition['className'])) . '_description"';
        }
        $arr[] = '                         "header.description" => array("type" => "textarea", "class" => "charCounter", "attrs" => array("maxlength" => 150' . $dependsDescr . '))' . ($i < count($columns) - 1 ? ', ' : '');
      } else {
        $arr[] = $build;
      }
    }

    $build = implode(PHP_EOL, $arr) . ');';


    // FIELDS ARRAY STRING
    $fieldArrayStr = 'array(' . $build;

    $build .= PHP_EOL . PHP_EOL;
    $build .= '  /** List params. */' . PHP_EOL;
    $listParams = '';
    foreach ($listColumnsArr as $listCol) {
      if (is_array($listCol)) {
        foreach ($listCol as $k => $v) {
          $listParams .= 'array("' . $k . '" => "' . $v . '"), ';
        }
      } else {
        $listParams .= '"' . $listCol . '", ';
      }
    }
    // LIST ARRAY STRING
    $listParams = rtrim(trim($listParams), ',');
    $build .= '  public $listParams = array(' . $listParams . ');' ;


    $this->buildMessageProperties($fieldArrayStr, $listParams, $definition);

    return $build;
  }


  private function buildMessageProperties($fieldArrayStr, $listParamsStr, $definition) {
    if (isset($definition['package']) && !empty($definition['package'])) {
      // Don't generate message_properties for commons
      return;
    }

    if (strpos(strtolower($definition['className']), 'translation') !== FALSE) {
      // Don't generate message_properties for translations
      return;
    }

    // DON'T GENERATE MESSAGE_PROPERTIES FOR MANY-TO-MANY TABLES
    $columns = $definition['columns'];

    if(!isset($columns['name']) && !isset($columns['id'])) {
      // NO "ID" OR "NAME" -> ONLY MANY-TO-MANY TABLE! Check for multiple PKS
      $pks = array();
      foreach ($columns as $cName => $cVal) {
        if (isset($cVal['primary']) && $cVal['primary'] == TRUE) {
          $pks[] = $cName;
        }
      }
      if (count($pks) > 1) {
        return;
      }
    }

    $entityName = str_replace("manager", '', strtolower($definition['className']));
    $filen = $entityName . $this->_suffix;
    $path = '..///language/russian/admin/generated';
    Doctrine_Lib::makeDirectories($path);
    $writePath = $path . '/' . $filen;
    if (file_exists($writePath)) {
      return;
    }

    // OMFG :) EVAL!!!
    eval('$fields = ' . $fieldArrayStr);
    eval('$listParams = array(' . $listParamsStr . ');');

    $columns = $definition['columns'];
    $filters = array();
    $dateFilters = array();
    $searchParams = array();
    foreach ($columns as $name => $column) {
      // Add search to all entities with name
      if ($name == 'name') {
        $searchParams[] = 'name';
      }
      // Add enums and booleans to filters
      if ($column['type'] == 'enum' || $column['type'] == 'boolean') {
        $filters[$name] = '';
      }
      // Add dates to date filters
      if ($column['type'] == 'timestamp' || $column['type'] == 'datetime') {
        $dateFilters[] = $name;
      }
    }

    // Add created_at to date filters
    $isTimeStampable = is_array($definition['actAs']) && array_key_exists('Timestampable', $definition['actAs']);
    if ($isTimeStampable) {
      $field = "created";
      // created is disabled ?
      if(isset($definition['actAs']['Timestampable']['created']['disabled'])) {
        $field = 'updated';
      }
      // default field name or the defined one?
      if(isset($definition['actAs']['Timestampable'][$field]['name'])) {
        $field = $definition['actAs']['Timestampable'][$field]['name'];
      } else {
        $field .= '_at';
      }
       $dateFilters[] = $field;
    }

    $relations = array();
    if (isset($definition['relations'])) {
      foreach ($definition['relations'] as $relName => $rel) {
        if ($rel['class'] != 'Header' && $rel['class'] != 'Image') {
          if ($rel['type'] == 0) {
            $relations[] = $relName . '.id';
          } elseif (isset($rel['refClass'])) {
            $relations[] = $relName . '.id';
          }
        }
      }
    }
    foreach ($relations as $rel) {
      $filters[$rel] = '';
    }



    $spaceCase = preg_replace('/(?!^)[[:upper:]][[:lower:]]/', ' $0', preg_replace('/(?!^)[[:upper:]]+/', ' $0', $entityName));
    $spaceCase = ucfirst($spaceCase);

    $lines = array();
    $lines[] = '//------------------------ ' . strtoupper($entityName) . ' > START -----------------------------------;';
    $lines[] = $this->mArr($entityName, 'name', $spaceCase . 's', 'menu');
    $lines[] = $this->mArr($entityName, 'list_title', $spaceCase . 's');

    // Search
    if (!empty($searchParams)) {
      $lines[] = $this->mArr($entityName, 'description', 'by ' . implode(' and ', $searchParams), 'search');
    }

    // Filters
    if (!empty($filters)) {
      $filters = array_keys($filters);
      foreach ($filters as $fname) {
        $lines[] = $this->mArr($entityName, 'filter.' . $fname . '_title', ucfirst($fname));
      }
    }

    // DateFilters
    if (!empty($dateFilters)) {
      foreach ($dateFilters as $fname) {
        $lines[] = $this->mArr($entityName, 'filter.' . $fname . '_title', ucfirst($fname));
      }
    }

    $lines[] = " ";

    // List params
    foreach ($listParams as $lp) {
      if (is_array($lp)) {
        $ks = array_keys($lp);
        $vs = array_values($lp);
        $lpk = implode('.', $ks) . '.' . implode('.', $vs) ;
        $lpv = implode('.', $ks) . ' ' . implode('.', $vs) ;
        $lines[] = $this->mArr($entityName, $lpk, ucfirst($lpv));
      } else {
        $lines[] = $this->mArr($entityName, $lp, ucfirst($lp));
      }
    }

    // Import
    $lines[] = " ";
    $lines[] = $this->mArr($entityName, 'form_title', 'Import ' . $spaceCase . 's', 'import');

    // Export
    $lines[] = " ";
    $lines[] = $this->mArr($entityName, 'form_title', 'Export ' . $spaceCase . 's', 'export');
    $lines[] = $this->mArr($entityName, 'batch_export_ids', 'Entities', 'add_edit');

    // Fields
    $lines[] = " ";
    $lines[] = $this->mArr($entityName, 'form_title', 'Add/Edit ' . $spaceCase, 'add_edit');
    $lines[] = $this->mArr($entityName, 'form_title', 'Add ' . $spaceCase, 'add');
    $lines[] = $this->mArr($entityName, 'id', 'id', 'add_edit');

    if (isset($definition['actAs']) && !empty($definition['actAs']) && is_array($definition['actAs']) && in_array('NestedSet', $definition['actAs'])) {
      $lines[] = $this->mArr($entityName, 'change_root_order_form_title', 'Root order', 'add_edit');
      $lines[] = $this->mArr($entityName, 'parent_id', 'Parent entity', 'add_edit');
      $lines[] = $this->mArr($entityName, 'parent_id.description', '', 'add_edit');
      $lines[] = $this->mArr($entityName, 'default_parent_category_value', '-- Please choose --', 'add_edit');
      $lines[] = $this->mArr($entityName, 'children', 'Children', 'add_edit');
    }

    foreach ($fields as $k => $v) {
      if ($v['type'] == 'multipleselect') {
        $lines[] = $this->mArr($entityName, $k . '.to', ucfirst($k), 'add_edit');
        $lines[] = $this->mArr($entityName, $k . '.from', ucfirst($k), 'add_edit');
        $lines[] = $this->mArr($entityName, $k, ucfirst($k), 'add_edit');
        $lines[] = $this->mArr($entityName, $k . '.description', '', 'add_edit');
      } elseif($v['type'] == 'select') {
        $lines[] = $this->mArr($entityName, $k, ucfirst($k), 'add_edit');
        $lines[] = $this->mArr($entityName, $k . '.description', '', 'add_edit');
        $lines[] = $this->mArr($entityName, $k . '.default', '-- Please choose --', 'add_edit');
      } else {
        if (isset($columns[$k]) && isset($columns[$k]['msgprop'])) {
          $lines[] = $this->mArr($entityName, $k, $columns[$k]['msgprop'], 'add_edit');
        } else {
          $lines[] = $this->mArr($entityName, $k, ucfirst($k), 'add_edit');
        }
        $lines[] = $this->mArr($entityName, $k . '.description', '', 'add_edit');
      }
    }

    // Actions
    $lines[] = " ";
    $actions = array('add' => '', 'edit' => '', 'delete'  => '');
    foreach ($actions as $k => $v) {
      $postFix = 'ed.';
      if ($k == 'delete') {
        $postFix = 'd.';
      }

      $lines[] = $this->mArr($entityName, $k, $spaceCase . ' successfully ' . $k . $postFix, 'messages');
    }

    $lines[] = '//------------------------ ' . strtoupper($entityName) . ' > END -------------------------------------;';

    $result = implode(PHP_EOL, $lines);

    $lang = 'ru';
    if ($lang != 'en' && !empty($lang)) {
      $result = $this->bing_translate($result, 'en', $lang);
      $result = str_replace('/ /', '//', $result);
      $result = str_replace('Имя', 'Название', $result);
    }

    $result = '<?php if (!defined("BASEPATH")) exit("No direct script access allowed");' . PHP_EOL . PHP_EOL . $result;


    file_put_contents($writePath, $result);

    // Add require to common file
//     $allFileN = 'includes.php';
//     $path = '..///language/russian/admin';
//     Doctrine_Lib::makeDirectories($path);
//     $writePath = $path . '/' . $allFileN;
//     $allIncludes = @file_get_contents($writePath);

//     if (empty($allIncludes)) {
//       $allIncludes = '<?php if (!defined("BASEPATH")) exit("No direct script access allowed");' . PHP_EOL . PHP_EOL;
//     }
//     $allIncludes .= 'require_once APPPATH . "language/russian/admin/generated/' . $filen . '";' . PHP_EOL;

//     file_put_contents($writePath, $allIncludes);

    // Write admin.php (CONFIG)
    if (strpos($entityName, 'translation') === FALSE) {
    $allFileN = 'admin.php';
    $path = '..///config/';
    Doctrine_Lib::makeDirectories($path);
    $writePath = $path . '/' . $allFileN;
    $admin = @file_get_contents($writePath);
    if (empty($admin)) {
    $admin =  '<?php  if(!defined("BASEPATH")) exit("No direct script access allowed");
/*
|--------------------------------------------------------------------------
| Admin base URL
|--------------------------------------------------------------------------
|
*/
$config["base_route"] = ADMIN_BASE_ROUTE;


/*
|--------------------------------------------------------------------------
| Admin menu items
|--------------------------------------------------------------------------
*/

$config["menu_items"] = array("admin" => array("admin",
																							 "adminlog"),
															"settings",
															"settingsgroup",
															"broadcast",
															"effect" => array("conversion",
														  									"conversionevent"));';
    }
    $admin = rtrim($admin, ';');
    $admin = rtrim($admin, ')');
    $admin = $admin . ')';
    $margin = str_repeat(' ', 30);
    $admin .= ',' . PHP_EOL . $margin . '"' . $entityName . '");';
    file_put_contents($writePath, $admin);
    }
  }


  /**
   *
   * Bing Translate
   * @param unknown_type $text
   * @param unknown_type $fromLang
   * @param unknown_type $intoLang
   * @param unknown_type $sleep
   */
  private function bing_translate($text, $fromLang, $intoLang, $sleep = null){
    $url = "http://api.microsofttranslator.com/v2/Http.svc/Translate?from=$fromLang&to=$intoLang&text=".urlencode($text)."&appId=CC29908D870DF1B8A485A0908266852560C63325&contentType=text/html";

    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $url);
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
    $response = curl_exec($curl);
    curl_close($curl);

    if ($sleep) {
      sleep($sleep);
    }

    if (!empty($response)) {
      $response = str_replace('<string xmlns="http://schemas.microsoft.com/2003/10/Serialization/">', '', $response);
      $response = str_replace('</string">', '', $response);
      $response = str_replace('</string>', '', $response);
      $response = html_entity_decode($response);
    }

    return $response;
  }

  /**
   * mArr.
   * @param unknown_type $entityName
   * @param unknown_type $key
   * @param unknown_type $value
   * @param unknown_type $type
   */
  private function mArr($entityName, $key, $value, $type = 'entity_list') {
    $value = str_replace('_', ' ', $value);
    if ($value != 'id') {
      $value = str_replace('id', '', $value);
    }
    return '$lang[\'admin.' . $type . '.' . strtolower($entityName) .'.' . $key . '\'] = \''. $value . '\';';
  }

// /**
//   * BuildFilters
//   * @param $definition
//   * @return string
//   */
//  private function buildFilters($definition) {
//    $columns = $definition['columns'];
//    $code = "";
//
//    // PHP Doc
//    $phpDoc = '  /**' . PHP_EOL;
//    $phpDoc .= '  * Filter Values' . PHP_EOL;
//    $phpDoc .= '  * @param string $filterName' . PHP_EOL;
//    $phpDoc .= '  * @return array' . PHP_EOL;
//    $phpDoc .= '  */' . PHP_EOL;
//
//    // Function
//    $funcStart = '  public function getFilterValues($filterName) {' . PHP_EOL;
//    $funcEnd = '  }';
//
//    // Get relations
//    $relations = array();
//    if (isset($definition['relations'])) {
//      foreach ($definition['relations'] as $relName => $rel) {
//        if ($rel['class'] != 'Header' && $rel['class'] != 'Image') {
//          if ($rel['type'] == 0 || isset($rel['refClass'])) {
//            $relations[$relName] = $rel;
//          }
//        }
//      }
//    }
//
//    // Get bools
//    $bools = array();
//    foreach ($columns as $field => $column) {
//      if (isset($column['type']) && $column['type'] == 'boolean') {
//        $bools[] = $field;
//      }
//    }
//
//    // Get enums
//    $enums = array();
//    foreach ($columns as $field => $column) {
//      if (isset($column['type']) && $column['type'] == 'enum') {
//        $enums[] = $field;
//      }
//    }
//
//    // Build function contents
//    $lines = "";
//
//    foreach ($relations as $alias => $relation) {
//      $line = '    if ($filterName == "' . $alias . '.id") {' . PHP_EOL;
//      $line .= '      return ManagerHolder::get("' . $relation['class'] .  '")->getAsViewArray();' . PHP_EOL;
//      $line .= '    }' . PHP_EOL;
//      $lines .= $line;
//    }
//
//    foreach ($bools as $fname) {
//      $line = '    if ($filterName == "' . $fname . '") {' . PHP_EOL;
//      $line .= '      return array("1" => lang("admin.yes"), "0" => lang("admin.no"));' . PHP_EOL;
//      $line .= '    }' . PHP_EOL;
//      $lines .= $line;
//    }
//
//    foreach ($enums as $fname) {
//      $line = '    if ($filterName == "' . $fname . '") {' . PHP_EOL;
//      $line .= '      return $this->getEnumAsViewArray("' . $fname . '");' . PHP_EOL;
//      $line .= '    }' . PHP_EOL;
//      $lines .= $line;
//    }
//
//    // Finally
//    if (!empty($lines)) {
//      $code = $phpDoc . $funcStart . $lines . $funcEnd;
//    }
//
//    $result = "";
//    if (!empty($code)) {
//      $result = PHP_EOL . PHP_EOL . $code . PHP_EOL;
//    }
//    return $result;
//  }


  /**
   * overridden
   * @see lib/database/Doctrine/Import/Doctrine_Import_Builder::buildRecord()
   */
  public function buildRecord(array $definition, array $translation = array())
  {
    if ( ! isset($definition['className'])) {
      throw new Doctrine_Import_Builder_Exception('Missing class name.');
    }

    $definition['topLevelClassName'] = $definition['className'];

    $this->writeDefinition($definition, $translation);
  }


//  /**
//   * overridden
//   * @see lib/database/Doctrine/Import/Doctrine_Import_Builder::writeTableClassDefinition()
//   */
//  public function writeTableClassDefinition(array $definition, $path, $options = array())
//  {
//    if ($prefix = $this->_classPrefix) {
//      $className = $prefix . $definition['tableClassName'];
//      if ($this->_classPrefixFiles) {
//        $fileName = $className . $this->_suffix;
//      } else {
//        $fileName = $definition['tableClassName'] . $this->_suffix;
//      }
//      $writePath = $path . DIRECTORY_SEPARATOR . $fileName;
//    } else {
//      $className = $definition['tableClassName'];
//      $fileName = $className . $this->_suffix;
//    }
//
//    if ($this->_pearStyle) {
//      $writePath = $path . DIRECTORY_SEPARATOR . str_replace('_', '/', $fileName);
//    } else {
//      $writePath = $path . DIRECTORY_SEPARATOR . $fileName;
//    }
//
//    $content = $this->buildTableClassDefinition($className, $definition, $options);
//    if (!file_exists($writePath)) {
//
//      Doctrine_Lib::makeDirectories(dirname($writePath));
//
//      file_put_contents($writePath, $content);
//    }
//  }


  /**
   * overridden
   * @see lib/database/Doctrine/Import/Doctrine_Import_Builder::writeDefinition()
   */
  public function writeDefinition(array $definition, array $translation = array())
  {
    $originalClassName = $definition['className'];

    // IF ENTITY HAS A TRANSLATION - MERGE COLUMNS
    if (!empty($translation)) {
      if (isset($translation['columns']['id'])) {
        unset($translation['columns']['id']);
      }
      if (isset($translation['columns']['language'])) {
        unset($translation['columns']['language']);
      }
      $entfk = strtolower($definition['connectionClassName']) . '_id';
      if (isset($translation['columns'][$entfk])) {
        unset($translation['columns'][$entfk]);
      }
      $definition['columns'] = array_merge($translation['columns'], $definition['columns']);
    }

    $fileName = $this->_getFileName($originalClassName, $definition);

    Doctrine_Lib::makeDirectories($this->_path);
    $writePath = $this->_path . DIRECTORY_SEPARATOR . $fileName;
    if (isset($definition['package']) && !empty($definition['package'])) {
      $writePath = str_replace('logic', 'logic' . DIRECTORY_SEPARATOR . $definition['package'] , $writePath);
    }

    $definitionCode = $this->buildDefinition($definition, $translation);
    if (isset($definition['generate_once']) && $definition['generate_once'] === TRUE) {
      if (!file_exists($writePath)) {
        $code = '<?php if (!defined("BASEPATH")) exit("No direct script access allowed");';
        $code .= PHP_EOL . $definitionCode;
        if ($this->_eolStyle) {
          $code = str_replace(PHP_EOL, $this->_eolStyle, $code);
        }
        Doctrine_Lib::makeDirectories(dirname($writePath));
        $bytes = file_put_contents($writePath, $code);
      }
    } else {
      $code = '<?php if (!defined("BASEPATH")) exit("No direct script access allowed");';
      $code .= PHP_EOL . $definitionCode;
      if ($this->_eolStyle) {
        $code = str_replace(PHP_EOL, $this->_eolStyle, $code);
      }
      Doctrine_Lib::makeDirectories(dirname($writePath));
      $bytes = file_put_contents($writePath, $code);
    }

    if (isset($bytes) && $bytes === false) {
      throw new Doctrine_Import_Builder_Exception("Couldn't write file " . $writePath);
    }
  }
}
